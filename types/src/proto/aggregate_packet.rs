// This file is @generated by prost-build.
/// option (gogoproto.goproto_getters) = false;
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Packet {
    /// number corresponds to the order of sends and receives, where a Packet
    /// with an earlier sequence number must be sent and received before a Packet
    /// with a later sequence number.
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// identifies the port on the sending chain.
    #[prost(string, tag = "2")]
    pub source_port: ::prost::alloc::string::String,
    /// identifies the channel end on the sending chain.
    #[prost(string, tag = "3")]
    pub source_channel: ::prost::alloc::string::String,
    /// identifies the port on the receiving chain.
    #[prost(string, tag = "4")]
    pub destination_port: ::prost::alloc::string::String,
    /// identifies the channel end on the receiving chain.
    #[prost(string, tag = "5")]
    pub destination_channel: ::prost::alloc::string::String,
    /// actual opaque bytes transferred directly to the application module
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// block height after which the packet times out
    /// ibc.core.client.v1.Height timeout_height = 7 \[(gogoproto.nullable) = false\];
    #[prost(message, optional, tag = "7")]
    pub timeout_height: ::core::option::Option<super::height::Height>,
    /// block timestamp (in nanoseconds) after which the packet times out
    #[prost(uint64, tag = "8")]
    pub timeout_timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InnerOp {
    #[prost(enumeration = "HashOp", tag = "1")]
    pub hash: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub prefix: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub suffix: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeafOp {
    #[prost(enumeration = "HashOp", tag = "1")]
    pub hash: i32,
    #[prost(enumeration = "HashOp", tag = "2")]
    pub prehash_key: i32,
    #[prost(enumeration = "HashOp", tag = "3")]
    pub prehash_value: i32,
    #[prost(enumeration = "LengthOp", tag = "4")]
    pub length: i32,
    #[prost(bytes = "vec", tag = "5")]
    pub prefix: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofMeta {
    #[prost(bytes = "vec", tag = "1")]
    pub hash_value: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub path_inner_op: ::core::option::Option<InnerOp>,
    #[prost(bytes = "vec", tag = "3")]
    pub real_value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubProof {
    #[prost(uint64, tag = "1")]
    pub number: u64,
    #[prost(message, repeated, tag = "2")]
    pub proof_meta_list: ::prost::alloc::vec::Vec<ProofMeta>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatePacket {
    #[prost(message, repeated, tag = "1")]
    pub packets: ::prost::alloc::vec::Vec<Packet>,
    #[prost(uint64, repeated, tag = "2")]
    pub packets_leaf_number: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<SubProof>,
    #[prost(string, tag = "4")]
    pub signer: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub height: ::core::option::Option<super::height::Height>,
    #[prost(message, repeated, tag = "6")]
    pub leafops: ::prost::alloc::vec::Vec<LeafOp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashOp {
    /// NO_HASH is the default if no data passed. Note this is an illegal argument some places.
    NoHash = 0,
    Sha256 = 1,
    Sha512 = 2,
    Keccak256 = 3,
    Ripemd160 = 4,
    /// ripemd160(sha256(x))
    Bitcoin = 5,
    Sha512256 = 6,
    Blake2b512 = 7,
    Blake2s256 = 8,
    Blake3 = 9,
}
impl HashOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HashOp::NoHash => "NO_HASH",
            HashOp::Sha256 => "SHA256",
            HashOp::Sha512 => "SHA512",
            HashOp::Keccak256 => "KECCAK256",
            HashOp::Ripemd160 => "RIPEMD160",
            HashOp::Bitcoin => "BITCOIN",
            HashOp::Sha512256 => "SHA512_256",
            HashOp::Blake2b512 => "BLAKE2B_512",
            HashOp::Blake2s256 => "BLAKE2S_256",
            HashOp::Blake3 => "BLAKE3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_HASH" => Some(Self::NoHash),
            "SHA256" => Some(Self::Sha256),
            "SHA512" => Some(Self::Sha512),
            "KECCAK256" => Some(Self::Keccak256),
            "RIPEMD160" => Some(Self::Ripemd160),
            "BITCOIN" => Some(Self::Bitcoin),
            "SHA512_256" => Some(Self::Sha512256),
            "BLAKE2B_512" => Some(Self::Blake2b512),
            "BLAKE2S_256" => Some(Self::Blake2s256),
            "BLAKE3" => Some(Self::Blake3),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LengthOp {
    /// NO_PREFIX don't include any length info
    NoPrefix = 0,
    /// VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
    VarProto = 1,
    /// VAR_RLP uses rlp int encoding of the length
    VarRlp = 2,
    /// FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
    Fixed32Big = 3,
    /// FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
    Fixed32Little = 4,
    /// FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
    Fixed64Big = 5,
    /// FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
    Fixed64Little = 6,
    /// REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
    Require32Bytes = 7,
    /// REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
    Require64Bytes = 8,
}
impl LengthOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LengthOp::NoPrefix => "NO_PREFIX",
            LengthOp::VarProto => "VAR_PROTO",
            LengthOp::VarRlp => "VAR_RLP",
            LengthOp::Fixed32Big => "FIXED32_BIG",
            LengthOp::Fixed32Little => "FIXED32_LITTLE",
            LengthOp::Fixed64Big => "FIXED64_BIG",
            LengthOp::Fixed64Little => "FIXED64_LITTLE",
            LengthOp::Require32Bytes => "REQUIRE_32_BYTES",
            LengthOp::Require64Bytes => "REQUIRE_64_BYTES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_PREFIX" => Some(Self::NoPrefix),
            "VAR_PROTO" => Some(Self::VarProto),
            "VAR_RLP" => Some(Self::VarRlp),
            "FIXED32_BIG" => Some(Self::Fixed32Big),
            "FIXED32_LITTLE" => Some(Self::Fixed32Little),
            "FIXED64_BIG" => Some(Self::Fixed64Big),
            "FIXED64_LITTLE" => Some(Self::Fixed64Little),
            "REQUIRE_32_BYTES" => Some(Self::Require32Bytes),
            "REQUIRE_64_BYTES" => Some(Self::Require64Bytes),
            _ => None,
        }
    }
}
