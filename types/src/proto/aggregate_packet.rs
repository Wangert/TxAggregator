// This file is @generated by prost-build.
/// option (gogoproto.goproto_getters) = false;
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Packet {
    /// number corresponds to the order of sends and receives, where a Packet
    /// with an earlier sequence number must be sent and received before a Packet
    /// with a later sequence number.
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// identifies the port on the sending chain.
    #[prost(string, tag = "2")]
    pub source_port: ::prost::alloc::string::String,
    /// identifies the channel end on the sending chain.
    #[prost(string, tag = "3")]
    pub source_channel: ::prost::alloc::string::String,
    /// identifies the port on the receiving chain.
    #[prost(string, tag = "4")]
    pub destination_port: ::prost::alloc::string::String,
    /// identifies the channel end on the receiving chain.
    #[prost(string, tag = "5")]
    pub destination_channel: ::prost::alloc::string::String,
    /// actual opaque bytes transferred directly to the application module
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// block height after which the packet times out
    /// ibc.core.client.v1.Height timeout_height = 7 \[(gogoproto.nullable) = false\];
    #[prost(message, optional, tag = "7")]
    pub timeout_height: ::core::option::Option<super::height::Height>,
    /// block timestamp (in nanoseconds) after which the packet times out
    #[prost(uint64, tag = "8")]
    pub timeout_timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InnerOp {
    #[prost(enumeration = "HashOp", tag = "1")]
    pub hash: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub prefix: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub suffix: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofMeta {
    #[prost(message, optional, tag = "2")]
    pub path_inner_op: ::core::option::Option<InnerOp>,
    #[prost(bytes = "vec", tag = "1")]
    pub hash_value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubProof {
    #[prost(uint64, tag = "1")]
    pub number: u64,
    #[prost(message, repeated, tag = "2")]
    pub proof_meta_list: ::prost::alloc::vec::Vec<ProofMeta>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatePacket {
    #[prost(message, repeated, tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<SubProof>,
    #[prost(string, tag = "4")]
    pub signer: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "1")]
    pub packets: ::prost::alloc::vec::Vec<Packet>,
    #[prost(message, optional, tag = "5")]
    pub height: ::core::option::Option<super::height::Height>,
    #[prost(uint64, repeated, tag = "2")]
    pub packets_leaf_number: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashOp {
    /// NO_HASH is the default if no data passed. Note this is an illegal argument some places.
    NoHash = 0,
    Sha256 = 1,
    Sha512 = 2,
    Keccak256 = 3,
    Ripemd160 = 4,
    /// ripemd160(sha256(x))
    Bitcoin = 5,
    Sha512256 = 6,
    Blake2b512 = 7,
    Blake2s256 = 8,
    Blake3 = 9,
}
impl HashOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HashOp::NoHash => "NO_HASH",
            HashOp::Sha256 => "SHA256",
            HashOp::Sha512 => "SHA512",
            HashOp::Keccak256 => "KECCAK256",
            HashOp::Ripemd160 => "RIPEMD160",
            HashOp::Bitcoin => "BITCOIN",
            HashOp::Sha512256 => "SHA512_256",
            HashOp::Blake2b512 => "BLAKE2B_512",
            HashOp::Blake2s256 => "BLAKE2S_256",
            HashOp::Blake3 => "BLAKE3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_HASH" => Some(Self::NoHash),
            "SHA256" => Some(Self::Sha256),
            "SHA512" => Some(Self::Sha512),
            "KECCAK256" => Some(Self::Keccak256),
            "RIPEMD160" => Some(Self::Ripemd160),
            "BITCOIN" => Some(Self::Bitcoin),
            "SHA512_256" => Some(Self::Sha512256),
            "BLAKE2B_512" => Some(Self::Blake2b512),
            "BLAKE2S_256" => Some(Self::Blake2s256),
            "BLAKE3" => Some(Self::Blake3),
            _ => None,
        }
    }
}
